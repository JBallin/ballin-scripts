#!/bin/bash

# TODO:
  # function that takes a filename and reads the gist using 'gist -r'
    # function to display names of the files?
  # INIT:
    # log in to gist
    # create gist and save id in config
  # gu should upload ballin_config too - that way have a backup of ur config
  # give error if id/sn null or if gist -r $id gives error?
    # need to make sure that the gist with that $id actually exists...tell them to run init?
    # or maybe just run it for them now?

id=$(ballin_config get gu.id)
url="https://gist.github.com/$id"
# TODO: generate file_suggestions based on API response instead of hard-coding
file_suggestions="bash_profile.sh, zshrc.sh, profile.sh, bashrc.sh, bash_completions, brew_list, brew_leaves, brew_cask, brew_services, npm_global, nvmrc, gitignore_global, gitconfig.cson, apm, atomconfig.cson, atom_keymap.cson, atom_snippets.cson, atom_styles.less, atom_init.coffee, vs_settings.json, vs_extensions, brackets_settings.json, brackets_keymap.json, brackets_extensions, brackets_disabled_extensions, vimrc, nanorc."

### TODO handle error when $id fails github API (check res code) (either nonexistant, deleted gist, skipped init etc)

# make sure given at least one argument
if [ ! -z $1 ]; then
  if [ $1 == open ]; then
    echo $url && open $url
  elif [ $1 == read ]; then
    # make sure given two arguments to read
    if [ ! -z $2 ]; then
      # if file exits, print it, else print the potential file options
      gist -r $id $2 || printf "\nOptions: $file_suggestions\n"
    else
      # user didn't provide file_name to read
      printf "Error: 'read' needs a filename.\n\nOptions: $file_suggestions\n"
    fi
  elif [ $1 == help ]; then
    # display the main help output
    ballin
  fi

else
  # no arguments given -> run gistUpdater

  u() {
    local file_name=$1
    local input=$2

    # helper func determines if gist needs to be updated
    gist_is_changed() {
      local changed

      # put DNE in raw_gist if the $file_name doesn't exist yet
      if ! gist -r $id $file_name > raw_gist; then echo "DNE" > raw_gist; fi
      # add "empty file" if $file_name empty so that gist doesnt give empty file error
      if [ ! -s $file_name ]; then
        echo "empty file" > $file_name
      fi
      # add newline to end of $file_name (if not already there), to match gist format
      sed -i '' -e '$a\' $file_name
      # remove extension for progress output
      file_without_extension=${file_name%.*}
      # check for changes in file
      if cmp --quiet $file_name raw_gist; then
        # only show backup of file if gist file is non-empty
        if [ "$(cat raw_gist)" != "empty file" ]; then
          echo "âœ” $file_without_extension"
        fi
        changed=1
      else
        # file updated
        # display that file is being "deleted" if it's empty
        if [ "$(cat $file_name)" == "empty file" ]; then
          echo "âœ–ï¸Ž $file_without_extension"
        else
          # if DNE then show symbol that created totally "new" file in gist, otherwise just show an "update" symbol
          if [ "$(cat $file_name)" == "DNE" ]; then
            echo "ðŸŽ‰ $file_without_extension"
          else
            echo "âœ™ $file_without_extension"
          fi
        fi
        changed=0
      fi
      rm raw_gist

      return $changed
    }

    # if $file_name doesn't exist in current dir and there are changes: update the file
    if [ ! -f $file_name ]; then
      $input > $file_name
      if gist_is_changed; then gist -u $id $file_name > /dev/null; fi
      rm $file_name
    else
      # don't overwrite existing files
      echo "Error: $file_name is an existing file, aborting so it doesn't get overwritten"
    fi
  }

  # only prints non-comments
  # TODO: add option to init to toggle whether or not want comments included?
  catWithoutCommentsAndBlankLines() {
    local file_name=$1
    sed -e '/^[[:blank:]]*#/d;s/#.*//; /^$/d' $file_name
  }

	(
    cd $HOME

    ### SHELL
    if [ -f .bash_profile ]; then
      u 'bash_profile.sh' 'cat .bash_profile'
    fi
    if [ -f .zshrc ]; then
      u 'zshrc.sh' 'cat .zshrc'
    fi
    if [ -f .profile ]; then
      u 'profile.sh' 'cat .profile'
    fi
    if [ -f .bashrc ]; then
      u 'bashrc.sh' 'cat .bashrc'
    fi
    # BASH COMPLETIONS
    if [ -d /usr/local/etc/bash_completion.d ]; then
      u 'bash_completions' 'ls /usr/local/etc/bash_completion.d'
    fi

    ### BREW
    if [ -x "$(command -v brew)" ]; then
  	  u 'brew_list' 'brew list'
  	  u 'brew_leaves' 'brew leaves'
  	  u 'brew_cask' 'brew cask list'
      u 'brew_services' 'brew services list'
    fi

    ### GIT
		if [ -f .gitignore_global ]; then
      u 'gitignore_global' 'cat .gitignore_global'
    fi
    if [ -f .gitconfig ]; then
      u 'gitconfig' 'cat .gitconfig'
    fi

    ### NODE
    # NPM
    if [ -x "$(command -v npm)" ]; then
      u 'npm_global' 'ls /usr/local/lib/node_modules'
    fi

    # YARN
    # TODO: remove last line (Done) which varies based on time
    # if [ -x "$(command -v npm)" ]; then
    #   u 'yarn_global' "yarn global list --depth=0 | sed '$d'"
    # fi

    # NVM
    if [ -f .nvmrc ]; then
      u 'nvmrc' 'cat .nvmrc'
    fi

    ### ATOM
    if [ -d .atom ]; then
      u 'apm' 'apm list --installed --no-color'
      u 'atom_config.cson' 'cat .atom/config.cson'
      u 'atom_keymap.cson' 'catWithoutCommentsAndBlankLines .atom/keymap.cson'
      u 'atom_snippets.cson' 'catWithoutCommentsAndBlankLines .atom/snippets.cson'
      # TODO: catWithout... not checking for CSS comments, just hashes. Need to updated func to check for those.
  		u 'atom_styles.less' 'catWithoutCommentsAndBlankLines .atom/styles.less'
  		u 'atom_init.coffee' 'catWithoutCommentsAndBlankLines .atom/init.coffee'
    fi

    ### VSCODE
    if [ -d .vscode ]; then
      (
        cd $HOME/Library/Application\ Support/Code/User/
          u 'vs_settings.json' 'cat settings.json'
          u 'vs_extensions' 'code --list-extensions'
          # TODO check if anything in snippets folder
            # u 'vs_snippets' 'ls snippets' TODO: figure out how snippets work in vs
          # KEYMAP: where is it stored? TODO: try and make key bindings so that it generates a file? maybe togglesidebar
      )
    fi

    ### BRACKETS
    (
      cd $HOME/Library/Application\ Support/
      if [ -d Brackets ]; then
        cd Brackets
        if [ -f brackets.json ]; then
          u 'brackets_settings.json' 'cat brackets.json'
        fi
        if [ -f keymap.json ]; then
          u 'brackets_keymap.json' 'cat keymap.json'
        fi
        u 'brackets_extensions' 'ls -A extensions/user/'
        u 'brackets_disabled_extensions' 'ls -A extensions/disabled/'
      fi
    )

    ### TEXT EDITORS
    # VIM
    if [ -f .vimrc ]; then
      u 'vimrc' 'cat .vimrc'
    fi

    # NANO
    if [ -f .nanorc ]; then
      u 'nanorc' 'cat .nanorc'
    fi

	)
fi
